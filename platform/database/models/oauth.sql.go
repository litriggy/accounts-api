// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.16.0
// source: oauth.sql

package db

import (
	"context"
	"database/sql"
)

const checkUserWallet = `-- name: CheckUserWallet :one
SELECT id, created_at, updated_at, user_id, wallet_addr, sec_pk, is_integrated, wallet_type, net_type FROM user_wallets
WHERE user_id = ? AND wallet_addr = ?
`

type CheckUserWalletParams struct {
	UserID     int32
	WalletAddr string
}

func (q *Queries) CheckUserWallet(ctx context.Context, arg CheckUserWalletParams) (UserWallet, error) {
	row := q.db.QueryRowContext(ctx, checkUserWallet, arg.UserID, arg.WalletAddr)
	var i UserWallet
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.UserID,
		&i.WalletAddr,
		&i.SecPk,
		&i.IsIntegrated,
		&i.WalletType,
		&i.NetType,
	)
	return i, err
}

const createOauth = `-- name: CreateOauth :execresult
INSERT INTO oauth (
    ` + "`" + `user_id` + "`" + `, ` + "`" + `oauth_id` + "`" + `, ` + "`" + `oauth_type` + "`" + `, ` + "`" + `version` + "`" + `
) VALUES (
    ?, ?, ?, ?
)
`

type CreateOauthParams struct {
	UserID    int32
	OauthID   string
	OauthType string
	Version   int32
}

func (q *Queries) CreateOauth(ctx context.Context, arg CreateOauthParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, createOauth,
		arg.UserID,
		arg.OauthID,
		arg.OauthType,
		arg.Version,
	)
}

const createSecondPassword = `-- name: CreateSecondPassword :exec
INSERT INTO user_pw (
    user_id, sec_pw
) VALUES (
    ?, ?
)
`

type CreateSecondPasswordParams struct {
	UserID int32
	SecPw  sql.NullString
}

func (q *Queries) CreateSecondPassword(ctx context.Context, arg CreateSecondPasswordParams) error {
	_, err := q.db.ExecContext(ctx, createSecondPassword, arg.UserID, arg.SecPw)
	return err
}

const createService = `-- name: CreateService :exec
INSERT INTO services (
    ` + "`" + `name` + "`" + `, ` + "`" + `symbol` + "`" + `, ` + "`" + `decimals` + "`" + `, ` + "`" + `image` + "`" + `, ` + "`" + `is_native` + "`" + `, ` + "`" + `contract_addr` + "`" + `
) VALUES (
    ?, ?, ?, ?, ?, ? 
)
`

type CreateServiceParams struct {
	Name         string
	Symbol       string
	Decimals     int32
	Image        sql.NullString
	IsNative     int32
	ContractAddr sql.NullString
}

func (q *Queries) CreateService(ctx context.Context, arg CreateServiceParams) error {
	_, err := q.db.ExecContext(ctx, createService,
		arg.Name,
		arg.Symbol,
		arg.Decimals,
		arg.Image,
		arg.IsNative,
		arg.ContractAddr,
	)
	return err
}

const createTx = `-- name: CreateTx :execresult
INSERT INTO transactions (
    ` + "`" + `from_id` + "`" + `, ` + "`" + `to_id` + "`" + `, ` + "`" + `service_id` + "`" + `, ` + "`" + `memo` + "`" + `, ` + "`" + `total_amount` + "`" + `
) VALUES (
    ?, ?, ?, ?, ?
)
`

type CreateTxParams struct {
	FromID      int32
	ToID        int32
	ServiceID   int32
	Memo        sql.NullString
	TotalAmount int64
}

func (q *Queries) CreateTx(ctx context.Context, arg CreateTxParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, createTx,
		arg.FromID,
		arg.ToID,
		arg.ServiceID,
		arg.Memo,
		arg.TotalAmount,
	)
}

const createTxDetails = `-- name: CreateTxDetails :execresult
INSERT INTO transaction_detail (
    ` + "`" + `transaction_id` + "`" + `, ` + "`" + `from` + "`" + `, ` + "`" + `to` + "`" + `, ` + "`" + `amount` + "`" + `, ` + "`" + `is_onchain` + "`" + `, ` + "`" + `txhash` + "`" + `
) VALUES (
    ?, ?, ?, ?, ?, ?
)
`

type CreateTxDetailsParams struct {
	TransactionID int32
	From          string
	To            string
	Amount        int64
	IsOnchain     int32
	Txhash        sql.NullString
}

func (q *Queries) CreateTxDetails(ctx context.Context, arg CreateTxDetailsParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, createTxDetails,
		arg.TransactionID,
		arg.From,
		arg.To,
		arg.Amount,
		arg.IsOnchain,
		arg.Txhash,
	)
}

const createUser = `-- name: CreateUser :execresult
INSERT INTO users (
    ` + "`" + `nickname` + "`" + `, ` + "`" + `email` + "`" + `, ` + "`" + `type` + "`" + `
) VALUES (
    ?, ?, ?
)
`

type CreateUserParams struct {
	Nickname string
	Email    string
	Type     string
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, createUser, arg.Nickname, arg.Email, arg.Type)
}

const createUserWallet = `-- name: CreateUserWallet :exec
INSERT INTO user_wallets (
    ` + "`" + `user_id` + "`" + `, ` + "`" + `wallet_addr` + "`" + `, ` + "`" + `sec_pk` + "`" + `, ` + "`" + `is_integrated` + "`" + `
) VALUES (
    ?, ?, ?, ?
)
`

type CreateUserWalletParams struct {
	UserID       int32
	WalletAddr   string
	SecPk        sql.NullString
	IsIntegrated int32
}

func (q *Queries) CreateUserWallet(ctx context.Context, arg CreateUserWalletParams) error {
	_, err := q.db.ExecContext(ctx, createUserWallet,
		arg.UserID,
		arg.WalletAddr,
		arg.SecPk,
		arg.IsIntegrated,
	)
	return err
}

const deleteOauthByOauth = `-- name: DeleteOauthByOauth :exec
DELETE FROM oauth
WHERE oauth_id = ? AND oauth_type = ?
`

type DeleteOauthByOauthParams struct {
	OauthID   string
	OauthType string
}

func (q *Queries) DeleteOauthByOauth(ctx context.Context, arg DeleteOauthByOauthParams) error {
	_, err := q.db.ExecContext(ctx, deleteOauthByOauth, arg.OauthID, arg.OauthType)
	return err
}

const deleteOauthByUserID = `-- name: DeleteOauthByUserID :exec
DELETE FROM oauth
WHERE user_id = ?
`

func (q *Queries) DeleteOauthByUserID(ctx context.Context, userID int32) error {
	_, err := q.db.ExecContext(ctx, deleteOauthByUserID, userID)
	return err
}

const deleteService = `-- name: DeleteService :exec
DELETE FROM services
WHERE id = ?
`

func (q *Queries) DeleteService(ctx context.Context, id int32) error {
	_, err := q.db.ExecContext(ctx, deleteService, id)
	return err
}

const findUserByEmail = `-- name: FindUserByEmail :many
SELECT ` + "`" + `id` + "`" + `, ` + "`" + `nickname` + "`" + `, ` + "`" + `email` + "`" + `  FROM users
WHERE LOWER(` + "`" + `email` + "`" + `) = LOWER(?) AND ` + "`" + `is_locked` + "`" + ` = 0
`

type FindUserByEmailRow struct {
	ID       int32
	Nickname string
	Email    string
}

func (q *Queries) FindUserByEmail(ctx context.Context, lower string) ([]FindUserByEmailRow, error) {
	rows, err := q.db.QueryContext(ctx, findUserByEmail, lower)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FindUserByEmailRow
	for rows.Next() {
		var i FindUserByEmailRow
		if err := rows.Scan(&i.ID, &i.Nickname, &i.Email); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findUserByNickname = `-- name: FindUserByNickname :many
SELECT ` + "`" + `id` + "`" + `, ` + "`" + `nickname` + "`" + `, ` + "`" + `email` + "`" + ` FROM users
WHERE LOWER(` + "`" + `nickname` + "`" + `) = LOWER(?) AND ` + "`" + `is_locked` + "`" + ` = 0
`

type FindUserByNicknameRow struct {
	ID       int32
	Nickname string
	Email    string
}

func (q *Queries) FindUserByNickname(ctx context.Context, lower string) ([]FindUserByNicknameRow, error) {
	rows, err := q.db.QueryContext(ctx, findUserByNickname, lower)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FindUserByNicknameRow
	for rows.Next() {
		var i FindUserByNicknameRow
		if err := rows.Scan(&i.ID, &i.Nickname, &i.Email); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllServices = `-- name: GetAllServices :many
SELECT id, name, symbol, decimals, image, is_native, contract_addr, net_type FROM services
`

func (q *Queries) GetAllServices(ctx context.Context) ([]Service, error) {
	rows, err := q.db.QueryContext(ctx, getAllServices)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Service
	for rows.Next() {
		var i Service
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Symbol,
			&i.Decimals,
			&i.Image,
			&i.IsNative,
			&i.ContractAddr,
			&i.NetType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBalance = `-- name: GetBalance :one
SELECT bal.amount, s.name, s.symbol, s.contract_addr, s.is_native, s.image, s.decimals FROM user_balances AS bal
LEFT JOIN services AS s
ON bal.service_id = s.id
WHERE bal.user_id = ? AND bal.service_id = ?
`

type GetBalanceParams struct {
	UserID    int32
	ServiceID int32
}

type GetBalanceRow struct {
	Amount       int64
	Name         sql.NullString
	Symbol       sql.NullString
	ContractAddr sql.NullString
	IsNative     sql.NullInt32
	Image        sql.NullString
	Decimals     sql.NullInt32
}

func (q *Queries) GetBalance(ctx context.Context, arg GetBalanceParams) (GetBalanceRow, error) {
	row := q.db.QueryRowContext(ctx, getBalance, arg.UserID, arg.ServiceID)
	var i GetBalanceRow
	err := row.Scan(
		&i.Amount,
		&i.Name,
		&i.Symbol,
		&i.ContractAddr,
		&i.IsNative,
		&i.Image,
		&i.Decimals,
	)
	return i, err
}

const getBalances = `-- name: GetBalances :many
SELECT bal.amount, s.name, s.symbol, s.contract_addr, s.is_native, s.image, s.decimals FROM user_balances AS bal
LEFT JOIN services AS s
ON bal.service_id = s.id
WHERE bal.user_id = ?
`

type GetBalancesRow struct {
	Amount       int64
	Name         sql.NullString
	Symbol       sql.NullString
	ContractAddr sql.NullString
	IsNative     sql.NullInt32
	Image        sql.NullString
	Decimals     sql.NullInt32
}

func (q *Queries) GetBalances(ctx context.Context, userID int32) ([]GetBalancesRow, error) {
	rows, err := q.db.QueryContext(ctx, getBalances, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetBalancesRow
	for rows.Next() {
		var i GetBalancesRow
		if err := rows.Scan(
			&i.Amount,
			&i.Name,
			&i.Symbol,
			&i.ContractAddr,
			&i.IsNative,
			&i.Image,
			&i.Decimals,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOauth = `-- name: GetOauth :one
SELECT id, created_at, updated_at, user_id, oauth_id, oauth_type, version FROM oauth
WHERE oauth_id = ? AND oauth_type = ?
`

type GetOauthParams struct {
	OauthID   string
	OauthType string
}

func (q *Queries) GetOauth(ctx context.Context, arg GetOauthParams) (Oauth, error) {
	row := q.db.QueryRowContext(ctx, getOauth, arg.OauthID, arg.OauthType)
	var i Oauth
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.UserID,
		&i.OauthID,
		&i.OauthType,
		&i.Version,
	)
	return i, err
}

const getPKFromWallet = `-- name: GetPKFromWallet :one
SELECT sec_pk FROM user_wallets
WHERE wallet_addr = ?
`

func (q *Queries) GetPKFromWallet(ctx context.Context, walletAddr string) (sql.NullString, error) {
	row := q.db.QueryRowContext(ctx, getPKFromWallet, walletAddr)
	var sec_pk sql.NullString
	err := row.Scan(&sec_pk)
	return sec_pk, err
}

const getServiceData = `-- name: GetServiceData :one
SELECT is_native, contract_addr, net_type FROM services
WHERE id = ?
`

type GetServiceDataRow struct {
	IsNative     int32
	ContractAddr sql.NullString
	NetType      sql.NullString
}

func (q *Queries) GetServiceData(ctx context.Context, id int32) (GetServiceDataRow, error) {
	row := q.db.QueryRowContext(ctx, getServiceData, id)
	var i GetServiceDataRow
	err := row.Scan(&i.IsNative, &i.ContractAddr, &i.NetType)
	return i, err
}

const getUser = `-- name: GetUser :one
SELECT id, created_at, updated_at, nickname, email, type, verified, is_locked FROM users
WHERE id = ?
`

func (q *Queries) GetUser(ctx context.Context, id int32) (User, error) {
	row := q.db.QueryRowContext(ctx, getUser, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Nickname,
		&i.Email,
		&i.Type,
		&i.Verified,
		&i.IsLocked,
	)
	return i, err
}

const getUserByOauth = `-- name: GetUserByOauth :one
SELECT id, created_at, updated_at, nickname, email, type, verified, is_locked FROM users
WHERE id in (
    SELECT user_id FROM oauth
    WHERE oauth_type = ? AND oauth_id = ?
)
`

type GetUserByOauthParams struct {
	OauthType string
	OauthID   string
}

func (q *Queries) GetUserByOauth(ctx context.Context, arg GetUserByOauthParams) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserByOauth, arg.OauthType, arg.OauthID)
	var i User
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Nickname,
		&i.Email,
		&i.Type,
		&i.Verified,
		&i.IsLocked,
	)
	return i, err
}

const getUserServices = `-- name: GetUserServices :many
SELECT us.service_id AS service_id, ub.amount AS amount, s.name, s.symbol, s.decimals, s.image, s.is_native, s.contract_addr, s.net_type 
FROM user_service AS us
LEFT JOIN services AS s
ON us.service_id = s.id
LEFT JOIN user_balances AS ub
ON ub.service_id = s.id AND ub.user_id = us.user_id
WHERE us.user_id = ?
`

type GetUserServicesRow struct {
	ServiceID    int32
	Amount       sql.NullInt64
	Name         sql.NullString
	Symbol       sql.NullString
	Decimals     sql.NullInt32
	Image        sql.NullString
	IsNative     sql.NullInt32
	ContractAddr sql.NullString
	NetType      sql.NullString
}

func (q *Queries) GetUserServices(ctx context.Context, userID int32) ([]GetUserServicesRow, error) {
	rows, err := q.db.QueryContext(ctx, getUserServices, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserServicesRow
	for rows.Next() {
		var i GetUserServicesRow
		if err := rows.Scan(
			&i.ServiceID,
			&i.Amount,
			&i.Name,
			&i.Symbol,
			&i.Decimals,
			&i.Image,
			&i.IsNative,
			&i.ContractAddr,
			&i.NetType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserWallets = `-- name: GetUserWallets :many
SELECT wallet_addr, is_integrated FROM user_wallets
WHERE user_id = ?
`

type GetUserWalletsRow struct {
	WalletAddr   string
	IsIntegrated int32
}

func (q *Queries) GetUserWallets(ctx context.Context, userID int32) ([]GetUserWalletsRow, error) {
	rows, err := q.db.QueryContext(ctx, getUserWallets, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserWalletsRow
	for rows.Next() {
		var i GetUserWalletsRow
		if err := rows.Scan(&i.WalletAddr, &i.IsIntegrated); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateBalance = `-- name: UpdateBalance :exec
INSERT INTO user_balances (
    ` + "`" + `user_id` + "`" + `, ` + "`" + `service_id` + "`" + `, ` + "`" + `amount` + "`" + `
) VALUES (
    ?, ?, ?
) ON DUPLICATE KEY UPDATE
amount = amount + VALUES(amount)
`

type UpdateBalanceParams struct {
	UserID    int32
	ServiceID int32
	Amount    int64
}

func (q *Queries) UpdateBalance(ctx context.Context, arg UpdateBalanceParams) error {
	_, err := q.db.ExecContext(ctx, updateBalance, arg.UserID, arg.ServiceID, arg.Amount)
	return err
}

const updateNickname = `-- name: UpdateNickname :exec
UPDATE users
SET nickname = ?
WHERE id = ?
`

type UpdateNicknameParams struct {
	Nickname string
	ID       int32
}

func (q *Queries) UpdateNickname(ctx context.Context, arg UpdateNicknameParams) error {
	_, err := q.db.ExecContext(ctx, updateNickname, arg.Nickname, arg.ID)
	return err
}

const updateTxHash = `-- name: UpdateTxHash :exec
UPDATE transaction_detail
SET txhash = ?
WHERE ` + "`" + `transaction_id` + "`" + ` = ? AND ` + "`" + `from` + "`" + ` = ?
`

type UpdateTxHashParams struct {
	Txhash        sql.NullString
	TransactionID int32
	From          string
}

func (q *Queries) UpdateTxHash(ctx context.Context, arg UpdateTxHashParams) error {
	_, err := q.db.ExecContext(ctx, updateTxHash, arg.Txhash, arg.TransactionID, arg.From)
	return err
}

const updateTxTotalAmount = `-- name: UpdateTxTotalAmount :exec
UPDATE transactions
SET total_amount = ?
WHERE ` + "`" + `id` + "`" + ` = ?
`

type UpdateTxTotalAmountParams struct {
	TotalAmount int64
	ID          int32
}

func (q *Queries) UpdateTxTotalAmount(ctx context.Context, arg UpdateTxTotalAmountParams) error {
	_, err := q.db.ExecContext(ctx, updateTxTotalAmount, arg.TotalAmount, arg.ID)
	return err
}

const userAddService = `-- name: UserAddService :exec
INSERT INTO user_service (
    user_id, service_id
) VALUES (
    ?, ?
)
`

type UserAddServiceParams struct {
	UserID    int32
	ServiceID int32
}

func (q *Queries) UserAddService(ctx context.Context, arg UserAddServiceParams) error {
	_, err := q.db.ExecContext(ctx, userAddService, arg.UserID, arg.ServiceID)
	return err
}

const userRemoveService = `-- name: UserRemoveService :exec
DELETE FROM user_service
WHERE user_id = ? AND service_id = ?
`

type UserRemoveServiceParams struct {
	UserID    int32
	ServiceID int32
}

func (q *Queries) UserRemoveService(ctx context.Context, arg UserRemoveServiceParams) error {
	_, err := q.db.ExecContext(ctx, userRemoveService, arg.UserID, arg.ServiceID)
	return err
}
